<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        :root {
          /* ê¸°ë³¸ ë°°ê²½ ë° í…ìŠ¤íŠ¸ */
          --bg-color:         #1e1e1e;
          --bg-soft:          #2a2a2a;
          --text-color:       #e0e0e0;
          --text-dim:         #999999;
          --border-color:     #333333;
        
          /* ê°•ì¡° ë° ê¸°ëŠ¥ ìƒ‰ */
          --primary-color:    #4D9DE0; /* í•˜ëŠ˜ìƒ‰ ê°•ì¡° */
          --danger-color:     #FF6B6B; /* ê²½ê³  ë˜ëŠ” ê°•í•œ ë”œ */
          --success-color:    #7AE582; /* íšŒë³µ/ì™„ë£Œ */
          --warning-color:    #FFD93D; /* ê²½ê³ /ì£¼ì˜ */
        
          /* ê·¸ë˜í”„ ë“± ì‹œê°ì  ìš”ì†Œìš© */
          --bar-color-1:      #FF6B6B;
          --bar-color-2:      #4D9DE0;
          --bar-color-3:      #7AE582;
          --bar-bg:           rgba(255, 255, 255, 0.06);
        }
        body {
            font-family: 'ë§‘ì€ ê³ ë”•', 'Malgun Gothic', Arial, sans-serif;
            font-size: 1em;
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--text-color)
        }
        label {
            color: var(--text-color);
            font-size: 0.9em;
            margin-right: 8px;
            display: inline-block;
            vertical-align: middle;
        }

        .container {
            max-width: 1200px;
            margin: 40px auto;
            border-radius: 18px;
            box-shadow: 0 8px 32px rgba(60,60,120,0.10);
            padding: 36px 30px 28px 30px;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 90vh;
        }
        .btn {
            background-color: var(--primary-color);
            color: black;
            padding: 7px 22px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.0em;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(60,60,120,0.07);
            transition: background 0.2s;
            outline: none;
        }
        .slt {
          background-color: #2a2a2a;
          color: #e0e0e0;
          border: 1px solid #444;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 0.9em;
          appearance: none;     /* í™”ì‚´í‘œ ì œê±° (ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥) */
          -webkit-appearance: none;
          -moz-appearance: none;
          background-image: url("data:image/svg+xml;charset=UTF-8,<svg fill='%23aaa' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
          background-repeat: no-repeat;
          background-position: right 10px center;
          background-size: 12px;
        }

        #conn-controls {
            display: inline-flex;
            margin-bottom: 18px;
            gap: 12px;
            align-items: center;
            justify-content: center;
            background: none;
            box-shadow: none;
        }
        #disconnectBtn {
            background: #43a047;
            color: #fff;
        }
        #disconnectBtn:hover {
            background: #388e3c;
        }
        #reconnectBtn {
            background: #e53935;
            color: #fff;
        }
        #reconnectBtn:hover {
            background: #b71c1c;
        }


        #damage-stats-panel {
            margin-bottom:18px;
            background:var(--bg-soft);
            border-radius:10px;
            padding:10px 16px;
            color:#444;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        
        .options-bar {
            display: flex;
            align-items: center;
            gap: 18px;
            margin-bottom: 2px;
            min-height: 32px;
        }
        .options-bar #conn-controls {
            justify-content: flex-end;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin: 0 0 0 18px;
            background: none;
            box-shadow: none;
            min-width: 120px;
        }
        .options-bar label {
            font-size: 1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
        }
        .options-bar input[type="checkbox"] {
            accent-color: #5a2d82;
            width: 18px;
            height: 18px;
            margin-right: 4px;
        }
        #damage-stats-list {
            margin:8px 0 0 18px;
            padding:0;
        }

        .runtime-bar {
            color: var(--text-color);
            margin: 8px 15px; 
            font-weight: bold;
        }

        
        .rank-li {
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
            gap: 10px;
            padding: 6px 10px;
            background: linear-gradient(90deg, #2c3a45 20%, #1a232a 100%);
            color: #aac4d6;
            margin-bottom: 3px;
            border-radius: 7px;
            border-left: 5px solid #607d8b;
            cursor: pointer;
        }
        .rank-1 {
            background: linear-gradient(90deg, #4a3e1a 20%, #2f2612 100%);
            color: #f3e38a;
            font-weight: bold;
            border-left: 5px solid #bfa642;
        }
        .rank-2 {
            background: linear-gradient(90deg, #3c3c3c 20%, #262626 100%);
            color: #d0d0d0;
            border-left: 5px solid #8e8e8e;
        }
        .rank-3 {
            background: linear-gradient(90deg, #4a2e1e 20%, #2b1a12 100%);
            color: #f3d8bd;
            border-left: 5px solid #a75d2a;
        }
        .rank-medal {
            font-size: 1.3em;
            margin-right: 4px;
        }
        .rank-badge {
            display: inline-block;
            min-width: 48px;
            text-align: center;
            background: #445244;
            color: #d0c9f6;
            border-radius: 8px;
            padding: 2px 8px;
            font-size: 0.98em;
            font-weight: 600;
            margin-right: 8px;
            letter-spacing: 0.5px;
            box-sizing: border-box;
            transition: background 0.2s, color 0.2s, border 0.2s;
            border: 2px solid #5a4a80;
        }        
        .rank-badge.me {
            background: #ffd1dc !important;
            color: #c2185b !important;
            border: 2px solid #ff80ab !important;
            font-weight: bold;
        }
        .rank-damage-share-bar {
            position: absolute;
            left: 110px;                /* badge + ì—¬ë°± */
            top: 86%;
            height: 10%;
            opacity: 0.8;
            z-index: 0;
            pointer-events: none;
            transition: width 0.4s;
        }
        .rank-percent-label{
            margin-left: auto;
            font-size: 0.95em;
            color: var(--text-color);
            z-index: 1;
            position: relative;
        }


        
        .detail-panel {
            margin-top: 18px;
            background: var(--bg-soft);
            border-radius: 16px;
            border: 2.5px solid #2a2a2a;
            box-shadow: 0 4px 24px rgba(255, 215, 64, 0.10), 0 1.5px 0 #2a2a2a inset;
            padding: 22px 36px;
            font-size: 1.13em;
            color: var(--text-color);
            min-height: 38px;
            position: static;
            left: unset;
            top: unset;
            transform: none;
            z-index: 20;
            margin-top: 18px;
            margin-bottom: 0;
            visibility: hidden;
        }
        .detail-panel.visible {
            visibility: visible;
        }
        /* detail-panel2ëŠ” detail-panelê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼ ì‚¬ìš© */
        #detail-panel2.detail-panel {
            margin-top: 12px;
        }
        .detail-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #ffb300;
            margin-bottom: 8px;
            display: block;
            letter-spacing: 1px;
        }
        .detail-stats {
            display: flex;
            flex-direction: column;
            gap: 7px;
            align-items: flex-start;
            font-size: 0.9em;
            margin-top: 2px;
        }
        .detail-label {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.9em;
            margin-right: 2px;
        }
        .detail-value {
            color: #c0b0fa;
            font-weight: bold;
            font-size: 0.9em;
            margin-right: 10px;
        }
        .detail-dot {
            color: #d84315;
            font-weight: bold;
        }

        .skill-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin-top: 22px;
            background: none;
            font-size: 0.9em;

            .skill-row {
                position: relative;
                display: flex;
                padding: 6px 12px;
                align-items: center;
                gap: 12px;
                font-size: 1em;
                cursor: pointer;
            }
            .skill-row .bar-bg {
              position: absolute;
              top: 2px;
              left: 0;
              bottom: 2px;
              background: #FF6B6B;
              opacity: 0.25;
              border-radius: 6px;
              z-index: 0;
              pointer-events: none;
            }         
            .skill-row > div {
              position: relative;
              z-index: 1;
              white-space: nowrap;
            }
            .skill-name {
              flex: 1;
            }
            .skill-damage, .skill-crit, .skill-addhit {
                font-size: 0.8em;
                text-align: right;
                min-width: 7em;
            }

            .skill-detail-row {
                position: relative;
                display: block;
                flex-wrap: wrap;
                gap: 12px;
                padding: 8px 122px 8px 12px; /* ì™¼ìª½ ì—¬ë°±ì€ ì¤„ì´ê³ , bar ê³µê°„ ê³ ë ¤í•œ ì˜¤ë¥¸ìª½ */
                background-color: #1f1f1f;
                border-left: 3px solid #4D9DE0; /* í¬ì¸íŠ¸ ì»¬ëŸ¬ */
                border-radius: 0 0 8px 8px;
                font-size: 0.85em;
                color: #ccc;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
                transition: background-color 0.2s ease;
            }
            .skill-detail-row > div{
                position: relative;
                display: flex;
                padding: 6px;
            }
            .skill-detail-row > div > div{
                padding-right: 1em;
            }
            .hidden {
                display: none;
            }   
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="damage-stats-panel">
            <div class="options-bar"> 
                <div id="conn-controls">
                    <button id="disconnectBtn" class="btn" style="display:none;">â›” ì—°ê²° ì¤‘ì§€</button>
                    <button id="reconnectBtn" class="btn">ğŸ”„ ì¬ì—°ê²°</button>
                </div>
                <button id="clearBtn" class="btn">ì´ˆê¸°í™”</button>
                <label for="calcmode">ì§‘ê³„ ë°©ì‹</label>
                <select id="calcmodechkbox" class="slt" name="calcmode">
                    <option value="all">ëª¨ë‘</option>
                    <option value="highest_hp">ìµœëŒ€ HP ëŒ€ìƒ</option>
                    <option value="most_attacked">ë”œ ì§‘ì¤‘ ëŒ€ìƒ</option>
                </select>
                <label>
                    <input type="checkbox" id="singleModeCheckbox">
                    <span>í—ˆìˆ˜ì•„ë¹„ ëª¨ë“œ</span>
                </label>
                <button id="saveAllBtn" class="btn">ì €ì¥</button>
                <button id="loadAllBtn" class="btn">ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
            <div id="runtime-display" class="runtime-bar">
                â±ï¸ ì „íˆ¬ì‹œê°„: <span id="runtime-text">0.00ì´ˆ</span>
            </div>            
            <ol id="damage-stats-list"></ol>
        </div>
        <div>
            <div id="detail-panel" class="detail-panel"></div>
        </div>
    </div>
    <script>
        let ws;
        const wsUrl = "ws://localhost:8080";
        const disconnectBtn = document.getElementById('disconnectBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const connControls = document.getElementById('conn-controls');

        const calcModeCheckBox = document.getElementById('calcmodechkbox');
        const bossCheckbox = document.getElementById('bossOnlyCheckbox');
        const singleModeCheckbox = document.getElementById('singleModeCheckbox');
        const clearBtn = document.getElementById('clearBtn');
        const runtimeText = document.getElementById('runtime-text');

        const damageStats = {};
        const damageByTarget = {};
        const damageByUserBySkill = {};
        const selfDamageByUser = {}
        const damageForDPS = {};
        const timeForDPS = { start: 0, end: 0, timeByTarget: {}}

        const jobMapping = {};
        const skillTrans = {src2name:{}, name2src:{}};
        const skillTrans2 = {src2name:{}}
        const skillTrans3 = {src2name:{}}
        const skillKey2Name = {}
        const dotFlag2Name = [
            ["bleed_flag", "ì¶œí˜ˆ"],
            ["dark_flag", "ì•”í‘"],
            ["fire_flag", "í™”ìƒ"],
            ["holy_flag", "ì‹ ì„±"],
            ["ice_flag", "ë¹™ê²°"],
            ["electric_flag", "ê°ì „"],
            ["poison_flag", "ì¤‘ë…"],
            ["mind_flag", "ì •ì‹ "],
            ["dump_flag123", "ë¬´ì†ì„±"]
        ];

        (function(){
            const dottypes = ["(ë„íŠ¸)", "(íŠ¹ìˆ˜)"];
            for(const dottype in dottypes){
                for(const [_,dotname] in dotFlag2Name){
                    dotkey = [dottype, dotname].join(" ")
                    skillKey2Name[dotkey] = dotkey;
                }
            }   
        })()

        const skillDetailOpened = {};        
        let selectedDetailUserId = null;
        (function(){
            document.getElementById('damage-stats-list').addEventListener('click', e => {
                const row = e.target.closest('.rank-li');
                if (!row) return;

                if (selectedDetailUserId === row.id) {
                    clearDetails();
                } else {
                    selectedDetailUserId = row.id;
                    showDetail(row.id);
                }
            });
            document.getElementById('detail-panel').addEventListener('click', e => {
                const row = e.target.closest('.skill-row');
                if (!row) return;

                const detail = row.nextElementSibling;
                if (detail && detail.classList.contains('skill-detail-row')) {
                    detail.classList.toggle('hidden');
                    skillDetailOpened[detail.id] = !detail.classList.contains('hidden');
                }
            });
        })()

        const bossTmpData = {id:0, hp:0};
        const selfTmpData = {id:0, total:0}
        
        let p_hpdff = null
        let bossOnly = false;
        let bossMode = null;
        let singleMode = false;
        let render_timeout = null;

        function getRuntimeMs(isBossMode, bossid){
            return isBossMode
                    ? timeForDPS.timeByTarget[bossid]
                        ? (timeForDPS.timeByTarget[bossid].end - timeForDPS.timeByTarget[bossid].start)
                        : 0
                    : (timeForDPS.end - timeForDPS.start);                    
        }

        function getTotalDamage(isBossMode, uid, bossid){
            return isBossMode 
                ? (damageForDPS[uid].total_by_target[bossid] ??  0) 
                : damageForDPS[uid].total;
        }

        function showDetail(user_id) {
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.innerHTML = '';
            detailDiv.classList.remove('visible');

            const stat = damageStats[user_id];
            const skillData = damageByUserBySkill[user_id];
            
            if (!stat || !skillData) {
                detailDiv.innerHTML = `<div style="color:#888;">ë°ì´í„° ì—†ìŒ</div>`;
                detailDiv.classList.add('visible');
                return;
            }
            const bossId = bossTmpData.id;
            const isBossMode = bossOnly && bossId;

            // ìŠ¤í‚¬ë³„ ë”œëŸ‰ ì§‘ê³„
            const skillRows = [];
            let total = 0;
            for (const skill in skillData) {
                const skillObj = isBossMode && skillData[skill].byTarget[bossId] ? skillData[skill].byTarget[bossId] : skillData[skill];                
                const dmg = skillObj ? skillObj.total || 0 : 0;
                if (dmg > 0) {     
                    const detail = {
                        crit: skillObj.count > 0 ? skillObj.cnt_crit / skillObj.count : ("+"+skillObj.cnt_crit), // íŒŒì£½ì§€ì„¸ë¡œ ë„íŠ¸ê°€ í¬ë¦¬í„°ì§€ëŠ” ê²½ìš° ê³ ë ¤
                        addhit: (() => {
							const initialSkillHits = skillObj.count - skillObj.cnt_addhit;
							return initialSkillHits > 0
								   ? (skillObj.cnt_addhit / initialSkillHits)
								   : 0;
						  })(),
                        dot: skillObj.dot,
                        cnt: skillObj.count || 0,
                        cnt_dot: skillObj.cnt_dot || 0,
                        min_dmg: skillObj.count > 0 ? skillObj.min_dmg : 0,
                        max_dmg: skillObj.count > 0 ?  skillObj.max_dmg : 0,
                        min_dot_dmg: skillObj.cnt_dot > 0 ? skillObj.min_dot_dmg : 0,
                        max_dot_dmg: skillObj.cnt_dot > 0 ? skillObj.max_dot_dmg : 0,
                    }
                    skillRows.push({ skill, dmg, detail });
                    total += dmg;
                }
            }
            if (skillRows.length === 0) {
                detailDiv.innerHTML = `<div style="color:#888;">ë°ì´í„° ì—†ìŒ</div>`;
                detailDiv.classList.add('visible');
                return;
            }
            skillRows.sort((a, b) => b.dmg - a.dmg);

            const count = stat.count || 1;
            const critRate = stat.crit ? ((stat.crit / count) * 100).toFixed(1) : 0;
            const addhitRate = stat.addhit ? ((stat.addhit / count) * 100).toFixed(1) : 0;
            let name;
            if (user_id == selfTmpData.id) {
                name = `<span class="rank-badge me" style="min-width:48px;display:inline-block;text-align:center;">ìì‹ </span>`;
            } else {
                name = `<span class="rank-badge" style="min-width:48px;display:inline-block;text-align:center;">${jobMapping[user_id] || user_id}</span>`;
            }
            shortDetailHtml = `
                <span class="detail-title">${name}</span>
                <div class="detail-stats">
                    <div><span class="detail-label">í¬ë¦¬ í™•ë¥ :</span>
                    <span class="detail-value">${critRate}%</span></div>
                    <div><span class="detail-label">ì¶”ê°€íƒ€ í™•ë¥ :</span>
                    <span class="detail-value">${addhitRate}%</span></div>
                </div>
            `;

            let table = `<div class="skill-table">`;
            skillRows.forEach((row, idx) => {
                const percent = total > 0 ? ((row.dmg / total) * 100).toFixed(2) : 0;
                // === ì˜¤ë²„ë© ê·¸ë˜í”„ ì¶”ê°€ ë¶€ë¶„ ì‹œì‘ ===
                const barColor = "#FF6B6B";
                // barì˜ heightë¥¼ 100%ê°€ ì•„ë‹ˆë¼ 90% ì •ë„ë¡œ, top/bottomì— ì—¬ë°±ì„ ì£¼ë©´ í–‰ë§Œ ë®ìŒ
                const bar = `<div style="
                    position:absolute;
                    left:0; top:2px; height:calc(100% - 4px); width:${percent}%;
                    background:${barColor};
                    opacity:0.28;
                    border-radius:6px;
                    z-index:0;
                    pointer-events:none;
                    transition:width 0.4s;
                "></div>`;
                const id = row.skill.replace(/[^\wê°€-í£]/g, '_');
                // === ì˜¤ë²„ë© ê·¸ë˜í”„ ì¶”ê°€ ë¶€ë¶„ ë ===
                table += `
                <div class="skill-row">
                    <div class="bar-bg" style="width: ${percent}%;"></div>
                    <div class="skill-name">${skillKey2Name[row.skill] ?? row.skill}</div>
                    <div class="skill-damage">${row.dmg.toLocaleString()} (${percent}%)</div>
                    <div class="skill-crit">í¬í™•: ${(row.detail.crit * 100).toFixed(2)}%</div>
                    <div class="skill-addhit">ì¶”í™•: ${(row.detail.addhit * 100).toFixed(2)}%</div>
                </div>
                <div id="${id}" 
                    class="skill-detail-row ${skillDetailOpened[id] ? "" : "hidden"}">
                    <div>
                        <div>íƒ€ê²©íšŸìˆ˜: ${row.detail.cnt}</div>
                        <div>ìµœëŒ€ ë°ë¯¸ì§€: ${row.detail.max_dmg}</div>
                        <div>ìµœì†Œ ë°ë¯¸ì§€: ${row.detail.min_dmg}</div>
                    </div>
                    <div>
                        <div>ë„íŠ¸íšŸìˆ˜: ${row.detail.cnt_dot}</div>
                        <div>ë„íŠ¸ë”œ: ${row.detail.dot} (${(row.detail.dot/row.dmg*100).toFixed(2)}%)</div>
                        <div>ë„íŠ¸ ìµœëŒ€: ${row.detail.max_dot_dmg}</div>
                        <div>ë„íŠ¸ ìµœì†Œ: ${row.detail.min_dot_dmg}</div>
                    </div>
                </div>
                `;
            });
            table += `</div>`;

            detailDiv.innerHTML = shortDetailHtml + table;            
            detailDiv.classList.add('visible');
        }

        function clearDetails() {
            selectedDetailUserId = null;
            const detailDiv = document.getElementById('detail-panel');
            detailDiv.classList.remove('visible');
        }

        function rankItem(rank, jobName, total, dps, critRate, addhitRate, totalRate){
            const li = document.createElement('li');
            li.className = 'rank-li';

            if (rank === 0) li.classList.add('rank-1');
            else if (rank === 1) li.classList.add('rank-2');
            else if (rank === 2) li.classList.add('rank-3');
            
            const badge = document.createElement('span');
            badge.className = 'rank-badge' + (jobName == "ìì‹ " ? ' me' : '');
            badge.textContent = jobName;
            const totalSpan = document.createElement('span');
            totalSpan.className = 'rank-total';
            totalSpan.textContent = `ì´í•©: ${total.toLocaleString()}`;
            const dpsSpan = document.createElement('span');
            dpsSpan.className = 'rank-dps';
            dpsSpan.textContent = `DPS: ${dps.toLocaleString()}`;
            const critSpan = document.createElement('span');
            critSpan.className = 'rank-crit';
            critSpan.textContent = `ì¹˜ëª…íƒ€: ${(critRate*100).toFixed(2)}%`;
            const addhitSpan = document.createElement('span');
            addhitSpan.className = 'rank-addhit';
            addhitSpan.textContent = `ì¶”ê°€íƒ€: ${(addhitRate*100).toFixed(2)}%`;

            // í¼ì„¼íŠ¸ ë¼ë²¨(ì„ íƒ)
            const percentLabel = document.createElement('span');
            percentLabel.className = "rank-percent-label";
            // í–‰ì´ 1ê°œë¿ì´ë©´ ë¬´ì¡°ê±´ 100%ë¡œ í‘œê¸°
            percentLabel.textContent = (totalRate*100).toLocaleString(undefined, {minimumFractionDigits: 1, maximumFractionDigits: 1}) + '%';

            // ë©”ë‹¬ ì•„ì´ì½˜
            const medal = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'][rank] ?? '';
            if (medal) {
                const medalSpan = document.createElement('span');
                medalSpan.className = 'rank-medal';
                medalSpan.textContent = medal;
                medalSpan.style.zIndex = '1';
                li.appendChild(medalSpan);
            } else {
                const rankNum = document.createElement('span');
                rankNum.style = "font-weight:bold; color:#888; margin-left:6px; margin-right:8px; z-index:1; position:relative;";
                rankNum.textContent = (rank + 1).toString().padStart(1, '0');
                li.appendChild(rankNum);
            }

            // === í–‰ ì „ì²´ ë°°ê²½ ê·¸ë˜í”„ ì¶”ê°€ ===
            const barColor = rank === 0 ? '#bfa642'
               : rank === 1 ? '#8e8e8e'  
               : rank === 2 ? '#c07e47' 
               : '#5a7391'; 
            const bar = document.createElement('div');
            bar.classList.add("rank-damage-share-bar");
            bar.style.background = barColor;
            bar.style.width = ((document.body.offsetWidth-232) * totalRate) + 'px'; //ì‹¤ì œí¬ê¸°ê¸°ë°˜ìœ¼ë¡œ í•˜ë©´ ê¹œë¹¡ì„ í˜„ìƒ ìˆìŒ

            badge.style.zIndex = '1';
            totalSpan.style.zIndex = '1';
            totalSpan.style.fontWeight = 'bold';
            dpsSpan.style.zIndex = '1';
            dpsSpan.style.fontWeight = 'bold';
            critSpan.style.zIndex = '1';
            critSpan.style.fontSize = '0.7em';
            addhitSpan.style.zIndex = '1';
            addhitSpan.style.fontSize = '0.7em';

            li.appendChild(bar);
            li.appendChild(badge);
            li.appendChild(totalSpan);
            li.appendChild(dpsSpan);
            li.appendChild(critSpan);
            li.appendChild(addhitSpan);
            li.appendChild(percentLabel);

            return li;
        }

        // ë°ë¯¸ì§€ ìˆœìœ„ í‘œì‹œ í•¨ìˆ˜
        function renderDamageStats() {
            let statsSource = damageStats;
            // ë³´ìŠ¤ë§Œ ë³´ê¸° ì²´í¬ì‹œ bossTmpData.id ì‚¬ìš©
            if (bossOnly && bossTmpData.id && damageByTarget[bossTmpData.id]) {
                statsSource = damageByTarget[bossTmpData.id].byUser;
            }
            const totalSum = Object.values(statsSource)
                .reduce((sum, stat) => sum + (stat.total || 0), 0);

            const statsList = document.getElementById('damage-stats-list');
            while (statsList.firstChild) statsList.removeChild(statsList.firstChild);

            const sorted = Object.entries(statsSource)
                .sort((a, b) => b[1].total - a[1].total)
                .slice(0, 12);
            sorted
                .filter(([user_id, stat])=>
                    jobMapping[user_id] != null
                )
                .forEach(([user_id, stat], idx) => {
                    const total = stat.total || 0;
                    const dps = Math.floor(getTotalDamage(bossOnly, user_id, bossTmpData.id)/(getRuntimeMs(bossOnly, bossTmpData.id) / 1000+1));
                    const count = stat.count || 1;
                    const critRate = stat.crit ? (stat.crit / count) : 0;
					const initialHits = count - stat.addhit;
                    const addhitRate = initialHits > 0 ? (stat.addhit / initialHits) : 0;
                    const totalRate = sorted.length === 1 ? 1 : totalSum > 0 ? total / totalSum : 0
                    const jobName = selfTmpData.id == user_id ? "ìì‹ " : (jobMapping[user_id] ? jobMapping[user_id] : user_id);
                    
                    const li = rankItem(idx, jobName, total, dps, critRate, addhitRate, totalRate);
                    li.id = user_id;
                    statsList.appendChild(li);
                });

            // ë””í…Œì¼ íŒ¨ë„ ìƒíƒœ ìœ ì§€
            if (selectedDetailUserId && damageStats[selectedDetailUserId]) {
                showDetail(selectedDetailUserId);
            } else {
                clearDetails();
            }
        }

        function clearDPS(){
            timeForDPS.start = timeForDPS.end  = 0; // ì•„ì£¼ ì˜›ë‚ ë¡œ
            Object.keys(timeForDPS.timeByTarget).forEach(key => {
                delete timeForDPS.timeByTarget[key];
            });
            Object.keys(damageForDPS).forEach(key => {
                damageForDPS[key].total = 0;
                damageForDPS[key].total_by_target = {};
            });
        }

        function clearDamages(){
            Object.keys(damageStats).forEach(key => {
                delete damageStats[key];
            });
            Object.keys(damageByTarget).forEach(key => {
                delete damageByTarget[key];
            });
            Object.keys(damageByUserBySkill).forEach(key => {
                delete damageByUserBySkill[key];
            });
            Object.keys(selfDamageByUser).forEach(key => {
                delete selfDamageByUser[key];
            });
            bossTmpData.hp = 0;
            selfTmpData.total = 0;
        }

        function updateBoss(tid, prev_hp, total){
            if (bossMode == "highest_hp") {
                if (bossTmpData.hp < prev_hp){
                    bossTmpData.id = tid;
                    bossTmpData.hp = prev_hp;
                }
            }
            else if(bossMode == "most_attacked"){
                if (bossTmpData.hp < total){
                    bossTmpData.id = tid;
                    bossTmpData.hp = total;
                }
            }
            else{
                bossTmpData.id = tid;
                bossTmpData.hp = total;
            }
        }

        function processDamage(dmg, uid, tid, flags, key1){
            const is_crit      = flags.crit_flag === 1;
            const is_addhit    = flags.add_hit_flag === 1;
            const is_dot       = (flags.dot_flag && flags.dot_flag2 && flags.dot_flag3) || flags.dot_flag4;
            const is_special   = flags.dot_flag || flags.dot_flag2 || flags.dot_flag3;

            if (!damageStats[uid]) 
                damageStats[uid] = {
                    count: 0,
                    total: 0,
                    crit: 0,
                    addhit: 0,
                }; 
            damageStats[uid].total += dmg;
            damageStats[uid].crit += is_crit;
            damageStats[uid].addhit += is_addhit;
            !is_dot && damageStats[uid].count++;
                            
            if (!damageByTarget[tid]) 
                damageByTarget[tid] = { total: 0, byUser: {}};
            if (!damageByTarget[tid].byUser[uid]) 
                damageByTarget[tid].byUser[uid] = {
                    count: 0,
                    total: 0,
                    crit: 0,
                    addhit: 0,
                };
            damageByTarget[tid].total += dmg;
            damageByTarget[tid].byUser[uid].crit += is_crit;
            damageByTarget[tid].byUser[uid].addhit += is_addhit;
            damageByTarget[tid].byUser[uid].total += dmg;
            !is_dot && damageByTarget[tid].byUser[uid].count++;

            if ((Date.now() - timeForDPS.end) > 1000 * 60){
                clearDPS();
                timeForDPS.start = Date.now();
                console.log("DPS ì´ˆê¸°í™”");
            }
            timeForDPS.end = Date.now();
            if (!timeForDPS.timeByTarget[tid]){
                timeForDPS.timeByTarget[tid] = {
                    start: Date.now(),
                    end: Date.now(),
                }
            }
            timeForDPS.timeByTarget[tid].end = Date.now();

            if (!damageForDPS[uid]){
                damageForDPS[uid] = {
                    total: 0,
                    total_by_target: {},
                };
            }
            damageForDPS[uid].total += dmg;
            if (!damageForDPS[uid].total_by_target[tid]) damageForDPS[uid].total_by_target[tid] = 0; 
            damageForDPS[uid].total_by_target[tid] += dmg;

            if(!damageByUserBySkill[uid])
                damageByUserBySkill[uid] = {}
            const damageByS = damageByUserBySkill[uid];
            let skey = null;
            if (key1 != 0){
                skey = skillTrans2.src2name[key1] || skillKey2Name[key1] || key1;               
            }
            else if(is_dot){
                const keyparts = ["(ë„íŠ¸)"];
                for (const [flag, label] of dotFlag2Name) if (flags[flag]) keyparts.push(label);
                if (keyparts.length == 1) keyparts.push("ë¬´ì†ì„±")
                skey = keyparts.join(" ")
            }
            else {            
                const keyparts = ["(íŠ¹ìˆ˜)"];
                for (const [flag, label] of dotFlag2Name) if (flags[flag]) keyparts.push(label);
                if (keyparts.length == 1) keyparts.push("ë¬´ì†ì„±")
                skey = keyparts.join(" ")
            }
            function skilldetailfact() {
                return {
                    total: 0,
                    dot: 0,
                    count: 0,
                    cnt_crit: 0,
                    cnt_addhit: 0,
                    cnt_dot: 0,
                    max_dmg: 0,
                    min_dmg: Infinity,
                    max_dot_dmg: 0,
                    min_dot_dmg: Infinity
                };
            }
            if (!damageByS[skey]){
                damageByS[skey] = skilldetailfact();
                damageByS[skey].byTarget = {};
            }
            const dt = damageByS[skey];
            if (!dt.byTarget[tid]) {
                dt.byTarget[tid] = skilldetailfact();
            }
            const dtt = dt.byTarget[tid];
            for (const kkk of [dt, dtt]){            
                kkk.total += dmg;
                kkk.dot += is_dot ? dmg : 0;
                if (!is_dot){
                    is_crit      && kkk.cnt_crit++;
                    is_addhit    && kkk.cnt_addhit++;
                    kkk.count++;
                    kkk.max_dmg = Math.max(kkk.max_dmg, dmg);
                    kkk.min_dmg = Math.min(kkk.min_dmg, dmg);
                }
                else{
                    kkk.cnt_dot++;
                    kkk.max_dot_dmg = Math.max(kkk.max_dot_dmg, dmg);
                    kkk.min_dot_dmg = Math.min(kkk.min_dot_dmg, dmg);
                }
            }
        }

        function processJson(obj) {
            // objëŠ” {type: "json", hide: bool, data: [...]}
            let items = obj.data;
            if (!Array.isArray(items) || items.length === 0) return;

            // ì‚¬ìš©í•˜ëŠ” ë°ì´í„° ì²˜ë¦¬
            let updated = false;
            items.forEach(entry => {
                if (!entry || typeof entry !== "object") return;                
                switch (entry.type) {       
                    case 100178:
                        if(entry.prev_hp > entry.current_hp && !singleMode){
                            p_hpdff = entry;
                        }
                        else {
                            p_hpdff = null;
                        }
                        break;
                    case 10701:
                        {
                            if (entry.damage > 2095071572) return;

                            const uid = entry.user_id;
                            if(!selfDamageByUser[uid]) {
                                selfDamageByUser[uid] = {
                                    id: uid,
                                    total: 0,
                                };
                            }
                            selfDamageByUser[uid].total += entry.damage;

                            if (selfTmpData.total < selfDamageByUser[uid].total) {
                                selfTmpData.id = uid;
                                selfTmpData.total = selfDamageByUser[uid].total;
                            }
                            
                            if (singleMode){
                                p_hpdff = {
                                    prev_hp:entry.damage,
                                    current_hp:0,
                                    target_id:entry.target_id,
                                }
                            }
                        }
                        break;
                    case 10299:
                        if(p_hpdff != null && entry.target_id == p_hpdff.target_id){
                            const dmg = Number(p_hpdff.prev_hp - p_hpdff.current_hp) || 0;
                            processDamage(dmg, entry.user_id, entry.target_id, entry.flags, entry.key1);
                            updateBoss(entry.target_id, p_hpdff.prev_hp, damageByTarget[entry.target_id].total);
                            updated = true;
                        }
                        break;
                    case 100041:
                        {
                            const uid = entry.user_id;
                            const sk = entry.skill_name.toLowerCase();
                            if (!jobMapping[entry.user_id]) {

                                if(sk.includes("expertwarrior")) jobMapping[uid] = "ì „ì‚¬";
                                else if(sk.includes("greatsword")) jobMapping[uid] = "ëŒ€ê²€";
                                else if(sk.includes("swordmaster")) jobMapping[uid] = "ê²€ìˆ ";
                            
                                else if(sk.includes("healer")) jobMapping[uid] = "íëŸ¬";
                                else if(sk.includes("monk")) jobMapping[uid] = "ìˆ˜ë„";
                                else if(sk.includes("priest")) jobMapping[uid] = "ì‚¬ì œ";

                                else if(sk.includes("bard")) jobMapping[uid] = "ìŒìœ ";                            
                                else if(sk.includes("battlemusician")) jobMapping[uid] = "ì•…ì‚¬";
                                else if(sk.includes("dancer")) jobMapping[uid] = "ëŒ„ì„œ";
                            
                                else if(sk.includes("fighter")) jobMapping[uid] = "ê²©ê°€";
                                else if(sk.includes("dualblades")) jobMapping[uid] = "ë“€ë¸”";
                                else if(sk.includes("highthief")) jobMapping[uid] = "ë„ì ";
                            
                                else if(sk.includes("highmage")) jobMapping[uid] = "ë¸ë¯¸";
                                else if(sk.includes("firemage")) jobMapping[uid] = "í™”ë²•";
                                else if(sk.includes("icemage")) jobMapping[uid] = "ë¹™ê²°";
                                else if(sk.includes("lightningmage")) jobMapping[uid] = "ì „ê²©";

                                else if(sk.includes("higharcher")) jobMapping[uid] = "ê¶ìˆ˜";
                                else if(sk.includes("arbalist")) jobMapping[uid] = "ì„ê¶";
                                else if(sk.includes("longbowman")) jobMapping[uid] = "ì¥ê¶";

                                else if(sk.includes("novicewarrior_shieldbash")) jobMapping[uid] = null;
                                else if(sk.includes("novice")) jobMapping[uid] = "ë‰´ë¹„";
                                else if(sk.includes("defaultattack")) jobMapping[uid] = null;

                                else{
                                    jobMapping[uid] = null                           
                                }
                            }

                            if (!skillKey2Name[entry.key1] && !skillTrans3.src2name[entry.skill_name]){
                                skillKey2Name[entry.key1] = skillTrans.src2name[entry.skill_name] || entry.skill_name;
                            }
                        }
                        break;
                    default:
                        console.log("failed " + entry.type)
                        // í•„ìš”ì‹œ ë‹¤ë¥¸ íƒ€ì… ì²˜ë¦¬
                        break;
                }
            });
            if (updated) {
                if (render_timeout) return;
                render_timeout = setTimeout(() => {
                    renderDamageStats();
                    render_timeout = null;
                }, 100);
            }
        }

        function setButtons(connected) {
            if (connected) {
                disconnectBtn.style.display = '';
                reconnectBtn.style.display = 'none';
                connControls.style.background = 'none';
            } else {
                disconnectBtn.style.display = 'none';
                reconnectBtn.style.display = '';
                connControls.style.background = 'none';
            }
        }

        function connect() {
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                setButtons(true);
            };

            ws.onmessage = (event) => {
                try {
                    const obj = JSON.parse(event.data);
                    switch (obj.type) {
                        case "json":
                            processJson(obj);
                            break;
                        case "skill":
                            skillTrans.src2name = obj.data;
                            break;
                        case "skill2":
                            skillTrans2.src2name = obj.data;
                            break;
                        case "skill3":
                            skillTrans3.src2name = obj.data;
                            break;
                        default:
                            console.warn("ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…:", obj.type);
                    }
                } catch (e) {
                    console.log("ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:", e, event.data);
                }
            };

            ws.onclose = () => {
                setButtons(false);
            };

            ws.onerror = (err) => {
                setButtons(false);
            };
        }

        disconnectBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
        };
        reconnectBtn.onclick = () => {
            connect();
        };
        calcModeCheckBox.onchange = () => {
            bossOnly = calcModeCheckBox.value != "all";
            bossMode = calcModeCheckBox.value;                
            renderDamageStats();
        };
        singleModeCheckbox.onchange = () => {
            singleMode = singleModeCheckbox.checked;                
            renderDamageStats();
        };
        clearBtn.onclick = () => {
            clearDPS();
            clearDamages();
            renderDamageStats();
        };;
        setInterval(() => {
            const elapsed = (getRuntimeMs(bossOnly, bossTmpData.id) / 1000).toFixed(2);
            runtimeText.textContent = `${elapsed}ì´ˆ`;
        }, 500);

        setButtons(false);
        connect();

        const saveAllBtn = document.getElementById('saveAllBtn');
        saveAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            function getKoreaTime(){
                const now = new Date();
                const kst = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Seoul' }));
                const yyyy = kst.getFullYear();
                const mm = String(kst.getMonth() + 1).padStart(2, '0');
                const dd = String(kst.getDate()).padStart(2, '0');
                const HH = String(kst.getHours()).padStart(2, '0');
                const MM = String(kst.getMinutes()).padStart(2, '0');
                const SS = String(kst.getSeconds()).padStart(2, '0');
                return `${yyyy}-${mm}-${dd}T${HH}-${MM}-${SS}`;
            }
            const data = {
                damageStats,
                damageByTarget,
                damageByUserBySkill,
                selfDamageByUser,
                damageForDPS,
                timeForDPS,
                jobMapping,
                skillTrans,
                skillTrans2,
                skillTrans3,
                skillKey2Name,
                dotFlag2Name,
                bossTmpData,
                selfTmpData
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `savedata_${getKoreaTime()}.json`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        };

        // ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ ë° íŒŒì¼ input ìƒì„±
        const loadAllBtn = document.getElementById('loadAllBtn');
        let fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';

        loadAllBtn.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            fileInput.value = '';
            fileInput.click();
        };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    const data = JSON.parse(ev.target.result);
                    // === ê¸°ì¡´ ë°ì´í„° ì´ˆê¸°í™” ===
                    Object.keys(damageStats).forEach(key => delete damageStats[key]);
                    Object.keys(damageByTarget).forEach(key => delete damageByTarget[key]);
                    Object.keys(damageByUserBySkill).forEach(key => delete damageByUserBySkill[key]);
                    Object.keys(selfDamageByUser).forEach(key => delete selfDamageByUser[key]);
                    Object.keys(damageForDPS).forEach(key => delete damageForDPS[key]);
                    Object.keys(timeForDPS).forEach(key => delete timeForDPS[key]);
                    Object.keys(jobMapping).forEach(key => delete jobMapping[key]);
                    Object.keys(skillTrans).forEach(key => delete skillTrans[key]);
                    Object.keys(skillTrans2).forEach(key => delete skillTrans2[key]);
                    Object.keys(skillKey2Name).forEach(key => delete skillKey2Name[key]);
                    Object.keys(bossTmpData).forEach(key => delete bossTmpData[key]);
                    Object.keys(selfTmpData).forEach(key => delete selfTmpData[key]);
                    dotFlag2Name.length = 0;

                    // === ë¶ˆëŸ¬ì˜¨ ë°ì´í„° ì ìš© ===
                    Object.assign(damageStats, data.damageStats || {});
                    Object.assign(damageByTarget, data.damageByTarget || {});
                    Object.assign(damageByUserBySkill, data.damageByUserBySkill || {});
                    Object.assign(selfDamageByUser, data.selfDamageByUser || {});
                    Object.assign(damageForDPS, data.damageForDPS || {});
                    Object.assign(timeForDPS, data.timeForDPS || {});
                    Object.assign(jobMapping, data.jobMapping || {});
                    Object.assign(skillTrans, data.skillTrans || {});
                    Object.assign(skillTrans2, data.skillTrans2 || {});
                    Object.assign(skillKey2Name, data.skillKey2Name || {});
                    Object.assign(bossTmpData, data.bossTmpData || {});
                    Object.assign(selfTmpData, data.selfTmpData || {});
                    if (Array.isArray(data.dotFlag2Name)) {
                        data.dotFlag2Name.forEach(v => dotFlag2Name.push(v));
                    }
                    renderDamageStats();
                    // alert('ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                } catch (err) {
                    alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + err);
                }
            };
            reader.readAsText(file, 'utf-8');
        };
    </script>
</body>
</html>